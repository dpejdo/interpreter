/* package expression

import (
	"fmt"
	"strings"
)

type AstPrinter struct {
}

func (p *AstPrinter) Print(exp Expression) string {
	return exp.Accept(p).(string)
}

func (p *AstPrinter) PrintRPN(exp Expression) string {
	return exp.Accept(p).(string)
}
*/
/*
	bnf table

<expression>   ::= <literal>

	| <unary>
	| <binary>
	| <grouping> ;

<literal>      ::= <NUMBER> | <STRING> | "true" | "false" | "nil" ;

<grouping>     ::= "(" <expression> ")" ;

<unary>        ::= ( "-" | "!" ) <expression> ;

<binary>       ::= <expression> <operator> <expression> ;

<operator>     ::= "==" | "!=" | "<" | "<=" | ">" | ">="

	| "+"  | "-"  | "*" | "/" ;
*/
/*
func (p *AstPrinter) VisitBinaryExpression(expression *Binary) interface{} {
	return p.parenthesize(expression.Operator.Lexeme, expression.Left, expression.Right)
}

func (p *AstPrinter) VisitGroupingExpression(expression *Grouping) interface{} {
	return p.parenthesize("group", expression.Expression)
}

func (p *AstPrinter) VisitLiteralExpression(expression *Literal) interface{} {
	if expression.Value == nil {
		return "nil"
	}
	if value, ok := expression.Value.(float64); ok {
		if value == float64(int(value)) {
			return fmt.Sprintf("%.1f", value)
		} else {
			return fmt.Sprintf("%g", value) // Keeps the precision for non-whole numbers
		}
	}

	return fmt.Sprintf("%v", expression.Value)
}

func (p *AstPrinter) VisitUnaryExpression(expression *Unary) interface{} {
	return p.parenthesize(expression.Operator.Lexeme, expression.Right)
}

func (p *AstPrinter) VisitTernaryExpression(expression *Ternary) interface{} {
	return fmt.Sprintf("%s ? %s : %s", expression.Condition, expression.TrueExpression, expression.FalseExpression)
}

func (p *AstPrinter) parenthesize(name string, expression ...Expression) string {
	var builder strings.Builder

	builder.WriteString("(")
	builder.WriteString(name)
	for _, expr := range expression {
		builder.WriteString(" ")
		builder.WriteString(expr.Accept(p).(string))
	}
	builder.WriteString(")")

	return builder.String()
}
*/
// #region rpn
/*
func (p *AstPrinter) VisitBinaryExpressionRPN(expression *Binary) interface{} {
	return p.parenthesize(expression.Operator.Lexeme, expression.Left, expression.Right)
}
func (p *AstPrinter) VisitGroupingRPN(expression *Grouping) interface{} {
	return p.rpn("", expression.Expression)
}

func (p *AstPrinter) VisitLiteralExpressionRPN(expression *Literal) interface{} {
	if expression.Value == nil {
		return "nil"
	}

	return fmt.Sprintf("%v", expression.Value)
}

func (p *AstPrinter) VisitUnaryExpressionRPN(expression *Unary) interface{} {
	return p.rpn(expression.Operator.Lexeme, expression.Right)
}
func (p *AstPrinter) rpn(name string, expression ...Expression) string {
	var builder strings.Builder

	for _, expr := range expression {
		builder.WriteString(" ")
		builder.WriteString(expr.Accept(p).(string))
	}
	builder.WriteString(" ")

	builder.WriteString(name)

	return builder.String()
	// #endregion  rpn
} */

